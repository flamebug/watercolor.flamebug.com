//
// Defaults
//

@import "../defaults/grid";

//
// Set the number of columns an element spans on the grid
//

@mixin column($cols: max, $prefix: 0, $suffix: 0, $grow: 0, $shrink: 0, $align: auto, $order: 0) {
	
	@if $cols == max {
		$grow: 1;
		$shrink: 1;
		flex-basis: 100%;
	}
	@else if $cols == auto {
		$grow: 1;
		$shrink: 1;
		flex-basis: auto;
	}
	@else {
		flex-basis: $cols * ($column-width + $gutter-width) - $gutter-width;
	}
	
	@include column-grow($grow);
	@include column-shrink($shrink);
	@include column-align($align);
	@include column-order($order);
	
	@include column-prefix($prefix);
	@include column-suffix($suffix);
}

//
// Set the column to automatically grow when there is available space
//

@mixin column-grow($grow: 1) {
	flex-grow: $grow;
}

//
// Set the column to automatically shrink when there is not enough available space
//

@mixin column-shrink($shrink: 1) {
	flex-shrink: $shrink;
}

//
// Set the alignment on the column, this will override the default alignment on the grid container
//

@mixin column-align($align: auto) {
	
	//default is auto
	@if $align == start {
		align-self: flex-start;
	}
	@else if $align == end {
		align-self: flex-end;
	}
	@else if $align == center {
		align-self: center;
	}
	@else if $align == baseline {
		align-self: baseline;
	}
	@else if $align == stretch {
		align-self: stretch;
	}
}

//
// Set the order of the column to override the normal ordering
//

@mixin column-order($order: 0) {
	
	//default is 0
	@if $order != 0 {
		order: $order;
	}
}

//
// Set the number of empty columns that should prefix the element on the grid
//

@mixin column-prefix($cols) {
	margin-left: ($cols * ($column-width + $gutter-width)) + ($gutter-width / 2);
}

//
// Set the number of empty columns that should follow the element on the grid
//

@mixin column-suffix($cols) {
	margin-right: ($cols * ($column-width + $gutter-width)) + ($gutter-width / 2);
}

//
// Grid Container
//

@mixin grid-container($wrap: wrap, $justify: start, $align-items: stretch, $align-content: stretch, $direction: forward) {
		
	display: flex;
	flex-wrap: $wrap;
	
	//default is start (flex-start)
	@if $justify == end {
		justify-content: flex-end;
	}
	@else if $justify == center {
		justify-content: center;
	}
	@else if $justify == between {
		justify-content: space-between;
	}
	@else if $justify == around {
		justify-content: space-around;
	}
	
	//default is stretch
	@if $align-items == start {
		align-items: flex-start;
	}
	@else if $align-items == end {
		align-items: flex-end;
	}
	@else if $align-items == center {
		align-items: center;
	}
	@else if $align-items == baseline {
		align-items: baseline;
	}
	
	//default is stretch
	@if $align-content == start {
		align-content: flex-start;
	}
	@else if $align-content == end {
		align-content: flex-end;
	}
	@else if $align-content == center {
		align-content: center;
	}
	@else if $align-content == between {
		align-content: space-between;
	}
	@else if $align-content == around {
		align-content: space-around;
	}
		
	//default is forward (column)
	@if $direction == reverse {
		flex-direction: column-reverse;
	}
	
	margin-right: $gutter-width * -0.5;
	margin-left: $gutter-width * -0.5;
}

//
// Flex Container
//

@mixin grid() {
	display: flex;
	flex-wrap: wrap;
}

//
// Build the container based on the breakpoint settings
//

@mixin container() {
	box-sizing: border-box;
	margin: 0 auto;
	padding-right: $gutter-width * 0.5;
	padding-left: $gutter-width * 0.5;
	
	@each $size, $cols in $breakpoints {
				
		@if $size == default {
			width: $cols * ($column-width + $gutter-width);
		}
		@else {
			@include breakpoint($size) {
				width: $cols * ($column-width + $gutter-width);
			}
		}
	}	
}

//
// Insert the given content within a media query given the breakpoint size
//

@mixin breakpoint($point) {
	$break: ($column-width + $gutter-width) * map-get($breakpoints, $point) + $gutter-width;
	
	@media screen and (min-width: $break) {
		@content;
	}
}

//
// clear any children within the element
//

@mixin clear-children() {
	&:after {
		content: "";
		display: table;
		clear: both;
	}
}

//
// Define the font styles that position the font within the typographic grid
//

@mixin font-size($size) {
	font-size: $size * 1em;
	line-height: line-height($size);
	margin-top: $line-height / $size * 1em;
	margin-bottom: $line-height / $size * 1em;
}

//
// Calculate the line height that will maintain vertical rhythm for the font size
//

@function line-height($size) {
	$lines-needed: ceil($size / $line-height);

	@return ($line-height / $size * $lines-needed);
}

//
// Convert Pixels to Em units (unitless)
//

@function em($pixels, $base: $base-font-size) {
	@return $pixels / ($base * 16);
}

//
// Convert Em units to Pixels (unitless)
//

@function px($ems, $base: $base-font-size) {
	@return $ems * $base * 16;
}