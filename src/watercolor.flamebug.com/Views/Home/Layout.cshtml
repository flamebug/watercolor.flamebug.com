@{
    ViewBag.Title = "Layout";
}

@section Styles {
	<link rel="stylesheet" href="~/styles/css/pages/layout.css">
}

@section Scripts {
		<script src="~/lib/prism/prism.js"></script>
}

<section id="layout-demo">

	<div class="container">

		<header>
			<h2>Layout</h2>
		</header>

		<p>
			Watercolor is based on an adaptive grid that allows a content-first approach to website design on a variety of screen sizes and devices.
			Unlike traditional responsive grids, which have a fixed number of columns, adaptive grids allow columns to be added as additional
			screen real estate becomes available. This flexibility allows the designer the ability to organize the content in a way that looks best
			on different sized screens, rather than the one-size-fits-all approach of responsive grids.  Resize your browser, or change your device
			orientation and watch the grid demo below to get an idea of how the adaptive grid works.
		</p>

	</div>

	<figure id="infinite">

		<div class="col1"></div>
		<div class="col2"></div>
		<div class="col3"></div>
		<div class="col4"></div>
		<div class="col5"></div>
		<div class="col6"></div>
		<div class="col7"></div>
		<div class="col8"></div>
		<div class="col9"></div>
		<div class="col10"></div>
		<div class="col11"></div>
		<div class="col12"></div>
		<div class="col13"></div>
		<div class="col14"></div>
		<div class="col15"></div>
		<div class="col16"></div>
		<div class="col17"></div>
		<div class="col18"></div>
		<div class="col19"></div>
		<div class="col20"></div>
		<div class="col21"></div>
		<div class="col22"></div>
		<div class="col23"></div>
		<div class="col24"></div>
		<div class="col25"></div>
		<div class="col26"></div>
		<div class="col27"></div>
		<div class="col28"></div>
		<div class="col29"></div>
		<div class="col30"></div>
		<div class="col31"></div>
		<div class="col32"></div>
		<div class="col33"></div>
		<div class="col34"></div>
		<div class="col35"></div>
		<div class="col36"></div>

	</figure>

</section>

<section id="grid-settings">

    <div class="container">

		<header>
			<h3>Grid Settings</h3>
		</header>

		<p>
			Default column and gutter sizes are defined in <code>defaults/_grid.scss</code> and are the basis for the structural grid.
			By default one column, including the gutter, is <code>5rem</code> wide, or 80px at the default base font size.
		</p>

		<table>

			<thead>
				<tr>
					<th style="width: 25%">variable</th>
					<th>description</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>$column-width</code></td>
					<td>This defines the width of the column, excluding the gutter. Default value: <code>3.5rem</code>.</td>
				</tr>
				<tr>
					<td><code>$gutter-width</code></td>
					<td>This defines the width of the gutter. Usually it looks best if the gutter is about half the width of the column. Default value: <code>1.5rem</code>.</td>
				</tr>
				<tr>
					<td><code>$breakpoints</code></td>
					<td>This defines the breakpoints that the page container will resize at. By default the following sizes are defined: <code>default</code>, <code>small</code>, <code>medium</code>, <code>large</code>, <code>extra-large</code>. See below for more information on the container breakpoints.</td>
				</tr>
			</tbody>
		</table>

    </div>

</section>

<section id="mixins">

    <div class="container">

		<header>
			<h3>Grid Mixins</h3>
		</header>

		<p>
			The grid @@mixins are defined in <code>modules/_grid.scss</code> and provide all of the functionality you should need for displaying your content in a standardized grid.
			The @@mixins listed below are the most important, but many helper @@mixins are also defined that can help you write more efficient code, especially when overriding column definitions at specific breakpoints.
			If you would like to see more on those feel free to check out the code on GitHub (eventually we'll add more doc for those also).
		</p>

		<table>

			<thead>
				<tr>
					<th style="width: 25%">mixin</th>
					<th>description</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>grid</code></td>
					<td>This is the @@mixin for declaring the grid container.</td>
				</tr>
				<tr>
					<td><code>column</code></td>
					<td>This is the @@mixin for declaring how column elements behave.</td>
				</tr>
				<tr>
					<td><code>container</code></td>
					<td>This is the @@mixin for declaring the page container that resizes at each breakpoint.</td>
				</tr>
				<tr>
					<td><code>breakpoint</code></td>
					<td>This is the @@mixin for declaring what content to apply to an element when a certain breakpoint is reached.</td>
				</tr>
			</tbody>

		</table>

    </div>

</section>

<section id="column-breakpoint">

    <div class="container">

		<header>
			<h3>Container Breakpoints</h3>
		</header>

		<p>
			Default breakpoints are defined in <code>defaults/_grid.scss</code> and provided to adapt to common devices, orientations, and resolutions.
			While the defaults should work for most, feel free to redefine the <code>$breakpoints</code> map as needed, things should work just fine.
		</p>

		<table>

			<thead>
				<tr>
					<th>size</th>
					<th>cols</th>
					<th>target</th>
				</tr>
			</thead>

			<tbody>

				<tr>
					<td>default</td>
					<td>4</td>
					<td>Mobile Portrait</td>
				</tr>
				<tr>
					<td>small</td>
					<td>6</td>
					<td>Mobile Landscape</td>
				</tr>
				<tr>
					<td>medium</td>
					<td>8</td>
					<td>Tablet Portrait</td>
				</tr>
				<tr>
					<td>large</td>
					<td>12</td>
					<td>Tablet Landscape / Desktop</td>
				</tr>
				<tr>
					<td>extra-large</td>
					<td>16</td>
					<td>Large Desktop</td>
				</tr>
			</tbody>

		</table>

		<pre><code class="language-css">
//
// Custom Breakpoints
//

$breakpoints: (
	default: 4,
	small: 6,
	medium: 8,
	large: 12,
	extra-large: 16,
	mega-super-large: 24 // <-- custom: 120ems wide
)</code></pre>

    </div>

</section>

<section id="auto-example">

    <div class="container">

		<header>
			<h3>Automatic Width Columns</h3>
		</header>

		<p>
			Automatic width columns are probably the most common need and they are super simple.
			Just add <code>@@include grid</code> to a container element and add <code>@@include column</code> to the child elements and you are all set.
		</p>

		<figure>

			<div>&nbsp;</div>

		</figure>

		<figure>

			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<figure>

			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<figure>

			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<pre><code class="language-markup">
&lt;figure&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;</code></pre>

		<pre><code class="language-css">
figure {
	@@include grid;

	div {
		@@include column;
	}
}</code></pre>

    </div>

</section>

<section id="fixed-example">

    <div class="container">

		<header>
			<h3>Fixed Width Columns</h3>
		</header>

		<p>
			Fixed width columns are nearly as easy as automatic width columns and allow situations where you want to fix a column to a particular size.
			Just add <code>@@include grid</code> to a container element and add <code>@@include column(x)</code>, where <code>x</code> is the number of columns, to the child elements and you are all set.
			Fixed width columns work perfectly along side automatic width columns, just set one column as fixed and the other as automatic and the latter will fill the remaining space on the row.
		</p>

		<figure>

			<div class="one">&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<figure>

			<div class="two">&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<figure>

			<div class="three">&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<figure>

			<div class="four">&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<pre><code class="language-markup">
&lt;figure&gt;
	&lt;div class="one"&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="two"&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="three"&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="four"&gt;&lt;/div&gt;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;</code></pre>

		<pre><code class="language-css">
figure {
	@@include grid;

	div {
		@@include column;

		&.one {
			@@include column(1);
		}
		&.two {
			@@include column(2);
		}
		&.three {
			@@include column(3);
		}
		&.four {
			@@include column(4);

            ~ div {
                display: none;

                @@include breakpoint(small) {
                    display: block;
                }
            }
		}
	}
}</code></pre>

    </div>

</section>

<section id="wrap-example">

    <div class="container">

		<header>
			<h3>Column Wrapping</h3>
		</header>

		<p>
			Column wrapping comes free without any extra code. If you have a number of elements such as a list of images that you want to wrap there is nothing extra you need to do.
			Just add <code>@@include grid</code> to a container element and add <code>@@include column(x)</code>, where <code>x</code> is the number of columns, to the child elements and you are all set.
		</p>

		<figure>

			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<p>
			If you want the last line of elements to be aligned differently check out the <code>$justify</code> parameter on the <code>grid</code> mixin.
			You can use values: <code>start</code>, <code>end</code>, <code>center</code>, <code>between</code>, and <code>around</code> to make the last line of items look exactly how you want.
		</p>

		<figure class="justify">

			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<pre><code class="language-markup">
&lt;figure&gt;
	&lt;div&gt;&lt;/div&gt;
    &hellip;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure class="justify"&gt;
	&lt;div&gt;&lt;/div&gt;
    &hellip;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;</code></pre>

		<pre><code class="language-css">
figure {
	@@include grid;

	&.justify {
		@@include grid($justify: between);
	}
	div {
		@@include column(2);
	}
}</code></pre>

    </div>

</section>

<section id="grow-and-shrink-example">

    <div class="container">

		<header>
			<h3>Growing and Shrinking Columns</h3>
		</header>

		<p>
			There may be some cases when you don't have enough elements to fit the entire line and want them to grow to fit the empty space.
			In this case you can add the <code>$grow: true</code> parameter to your <code>column</code> and the browser will take care of the rest.
			Note that if there isn't enough space on the line the elements will wrap (and wrapped items will expand as needed to fill the whole line), but if there is excess space the elements will expand to fill it.
		</p>

		<figure class="grow">

			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<p>
			Other cases may pop up when you have more elements than would fit on a line, but simply want them to shrink to fit, rather than wrap.
			In this case you can add the <code>$wrap: false</code> parameter to your <code>grid</code> and <code>$shrink: true</code> to your <code>column</code> and let the browser do the heavy lifting.
			Note that if you don't have enough elements to fit the entire row the elements won't expand by default.
		</p>

		<figure class="shrink">

			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<p>
			One final case could be where at some screen sizes you have too many elements to fit, but at others the elements are too small.
			In this case you can combine the previous two parameters to have your elements both shrink and grow as needed.
			Note that behind the scenes the automatic width sizing included on the basic <code>@@include column</code> sets both of these parameters to true, so it is always cleaner to avoid setting both in code and just let the defaults do the job.
		</p>

		<figure class="grow-and-shrink">

			<div>&nbsp;</div>
			<div>&nbsp;</div>
			<div>&nbsp;</div>

		</figure>

		<pre><code class="language-markup">
&lt;figure class="grow"&gt;
	&lt;div&gt;&lt;/div&gt;
    &hellip;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure class="shrink"&gt;
	&lt;div&gt;&lt;/div&gt;
    &hellip;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure class="grow-and-shrink"&gt;
	&lt;div&gt;&lt;/div&gt;
    &hellip;
	&lt;div&gt;&lt;/div&gt;
&lt;/figure&gt;</code></pre>

		<pre><code class="language-css">
figure.grow {
    @@include grid;

    div {
		@@include column(2, $grow: true);
	}
}
figure.shrink {
    @@include grid($wrap: no-wrap);

    div {
		@@include column(2, $shrink: true);
	}
}
figure.grow-and-shrink {
    @@include grid($wrap: no-wrap);

    div {
		/* for example purposes only, better to use '@@include column' parameter-less */
		@@include column(2, $shrink: true, $grow: true);
	}
}</code></pre>

    </div>

</section>

<section id="nested-example">

    <div class="container">

		<header>
			<h3>Nested Columns</h3>
		</header>

		<p>
			Nested columns are just a matter of nesting a grid element inside of any column element.
			The nested grid will automatically contain the same number of columns as the parent element.
			Any grid or column parameters can be applied to the nested grid and will function just the same as a normal grid.
		</p>

		<figure>

			<div>

				<figure>

					<div>

						<figure>

							<div>&nbsp;</div>
							<div>&nbsp;</div>

						</figure>

					</div>

					<div>

						<figure>

							<div>&nbsp;</div>

						</figure>

					</div>

				</figure>

			</div>

		</figure>

		<p>
			Note: If the parent column of the nested grid has any padding that will cause the child grid to not contain the same number of columns.
			In that case it is usually safest to define the nested grid columns as automatic width columns to save yourself headaches.
		</p>

		<pre><code class="language-markup">
&lt;figure&gt;
	&lt;div&gt;
		&lt;figure&gt;
			&lt;div&gt;
				&lt;figure&gt;
					&lt;div&gt;&lt;/div&gt;
					&lt;div&gt;&lt;/div&gt;
				&lt;/figure&gt;
			&lt;/div&gt;
			&lt;div&gt;
				&lt;figure&gt;
					&lt;div&gt;&lt;/div&gt;
				&lt;/figure&gt;
			&lt;/div&gt;
		&lt;/figure&gt;
	&lt;/div&gt;
&lt;/figure&gt;</code></pre>

		<pre><code class="language-css">
figure {
	@@include grid;

	div {
		@@include column;
	}
}</code></pre>

    </div>

</section>

<section id="prefix-example">

    <div class="container">

		<header>
			<h3>Column Prefixes</h3>
		</header>

		<p>
			Column prefixes can come in handy if you want the element to align to the right with blank space prefixing it to the left.
			To do this just add the <code>$prefix: x</code> parameter to your column definition, where <code>x</code> is the number of columns.
			This works quite easily when using a grid with only one column.
			When you have multiple columns it isn't that more difficult but you need to keep in mind your total row size at any given breakpoint to prevent wrapping (unless of course you disabled wrapping on the grid element).
		</p>

		<figure>

			<div class="prefix-3">&nbsp;</div>

		</figure>

		<figure>

			<div class="prefix-2">&nbsp;</div>

		</figure>

		<figure>

			<div class="prefix-1">&nbsp;</div>

		</figure>

		<figure>

			<div class="prefix-0">&nbsp;</div>

		</figure>

		<pre><code class="language-markup">
&lt;figure&gt;
	&lt;div class="prefix-3"&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="prefix-2"&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="prefix-1"&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="prefix-0"&gt;&lt;/div&gt;
&lt;/figure&gt;</code></pre>

		<pre><code class="language-css">
figure {
    @@include grid;

    .prefix-3 {
		@@include column($prefix: 3);
	}
    .prefix-2 {
		@@include column($prefix: 2);
	}
    .prefix-1 {
		@@include column($prefix: 1);
	}
    .prefix-0 {
		@@include column;
	}
}</code></pre>

    </div>

</section>

<section id="suffix-example">

    <div class="container">

		<header>
			<h3>Column Suffixes</h3>
		</header>

		<p>
			This is basically the same as using a prefix, but the empty space will trail the column.
			To do this just add the <code>$suffix: x</code> parameter to your column definition, where <code>x</code> is the number of columns.
			This works quite easily when using a grid with only one column.
			When you have multiple columns it isn't that more difficult but you need to keep in mind your total row size at any given breakpoint to prevent wrapping (unless of course you disabled wrapping on the grid element).
		</p>

		<figure>

			<div class="suffix-3">&nbsp;</div>

		</figure>

		<figure>

			<div class="suffix-2">&nbsp;</div>

		</figure>

		<figure>

			<div class="suffix-1">&nbsp;</div>

		</figure>

		<figure>

			<div class="suffix-0">&nbsp;</div>

		</figure>

		<pre><code class="language-markup">
&lt;figure&gt;
	&lt;div class="suffix-3"&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="suffix-2"&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="suffix-1"&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;div class="suffix-0"&gt;&lt;/div&gt;
&lt;/figure&gt;</code></pre>

		<pre><code class="language-css">
figure {
    @@include grid;

    .suffix-3 {
		@@include column($suffix: 3);
	}
    .suffix-2 {
		@@include column($suffix: 2);
	}
    .suffix-1 {
		@@include column($suffix: 1);
	}
    .suffix-0 {
		@@include column;
	}
}</code></pre>

    </div>

</section>